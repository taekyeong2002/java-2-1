# <h1> 202130118 송태경

# 6월 14일 강의
<h2> 자바의 입출력 스트림
<h3>입출력 장치와 자바 응용 프로그램 연결
<h4>입력 스트림 : 입력 장치로부터 자바 프로그램으로 데이터를 전달하는 객체
<h4>출력 스트림 : 자바 프로그램에서 출력 장치로 데이터를 보내는 객체
<h3>특징
<h4>입출력 스트림 기본 단위 : 바이트
<h4>단방향 스트림, 선입선출 구조
<h4>자바 프로그램 개발자는 직접 입력 장치에서 읽지 않고
입력 스트림을 통해 읽으며, 스크린 등 출력 장치에 직접
출력하지 않고 출력 스트림에 출력하면 된다.
<h2>자바의 입출력 스트림 종류
<h3>문자 스트림
<h4>문자만 입출력하는 스트림
<h4> 문자가 아닌 바이너리 데이터는 스트림에서 처리하지 못함
<h4> 문자가 아닌 데이터를 문자 스트림으로 출력하면 깨진 기호가 출력
<h4> 바이너리 파일을 문자 스트림으로 읽으면 읽을 수 없는 바이트가 생
겨서 오류 발생
예) 텍스트 파일을 읽는 입력 스트림
<h3> 바이트 스트림
<h4> 입출력 데이터를 단순 바이트의 흐름으로 처리
<h4> 문자 데이터 든 바이너리 데이터든 상관없이 처리 가능
예)바이너리 파일을 읽는 입력 스트림
<h2>스트림 연결
<h3>여러 개의 스트림을 연결하여 사용할 수 있음
 <h4>예) 키보드에서 문자를 입력받기 위해 System.in과
InputStreamReader를 연결한 코드
<h2>문자 스트림으로 텍스트 파일 읽기
<h3>1.파일 입력 스트림 생성(파일 열기)
<h4>스트림을 생성하고 파일을 열어 스트림과 연결
<h4>FileReader fin = new FileReader("c:\\test.txt");
<h3>2. 파일 읽기
<h4>read()로 문자 하나 씩 파일에서 읽음
<h4>int c;
<h4>while((c = fin.read()) != -1) { // 문자를 c에 읽음. 파일 끝까지 반복
<h4>System.out.print((char)c); // 문자 c 화면에 출력
<h4>}
<h3>3. 스트림 닫기
<h4>스트림이 더 이상 필요 없으면 닫아야 함. 닫힌 스트림에서는 읽을 수 없음
<h4>close()로 스트림 닫기
<h4>fin.close();
<h2>파일 입출력과 예외 처리
<h3>파일 입출력 동안 예외 발생 가능
<h4>스트림 생성 동안 : FileNotFoundException 발생 가능
<h5>파일의 경로명이 틀리거나, 디스크의 고장 등으로 파일을 열 수 없음
<h5>FileReader fin = new FileReader("c:\\test.txt"); // FileNotFoundException 발생가능
<h4> 파일 읽기, 쓰기, 닫기를 하는 동안 : IOException 발생 가능
<h5> 디스크 오동작, 파일이 중간에 깨진 경우, 디스크 공간이 모자라서 파일 입출력 불가
<h5>int c = fin.read(); // IOException 발생 가능
<h2>바이트 스트림으로 바이너리 파일 쓰기
<h3> 바이너리 값을 파일에 저장하기
<h4> 프로그램 내의 변수, 배열, 버퍼에 든 바이너리 값을 파일에 그대로 기록
<h5>FileOutputStream 클래스 이용
<h4>1. 파일 출력 스트림 생성(파일 열기)
<h5>스트림을 생성하고 파일을 열어 스트림과 연결
<h5>FileOutputStream fout = new FileOutputStream("c:\\Temp\\test.out");
<h4>2. 파일 쓰기
<h5>write()로 문자 하나 씩 파일에 기록
<h5>byte b[] = {7,51,3,4,-1,24};
<h5>for(int i=0; i<b.length; i++) fout.write(b[i]); //배열 b를 바이너리 그대로 기록
<h4>3. 스트림 닫기
<h5>close()로 스트림 닫기
<h2>File 클래스
<h3> 파일의 경로명 및 속성을 다루는 클래스
<h4> java.io.File
<h4> 파일과 디렉터리 경로명의 추상적 표현
<h3> 파일 이름 변경, 삭제, 디렉터리 생성, 크기 등 파일 관리
<h3>File 객체에는 파일 읽기/쓰기 기능 없음
<h4> 파일 입출력은 파일 입출력 스트림 이용
<h2>File 객체 셍성
<h3>생성자에 파일 경로명을 주어 File 객체 생성
<h3>File f = new File("c:\\Temp\\test.txt");
<h3> 디렉터리와 파일명을 나누어 생성자 호출
<h3>File f = new File("c:\\Temp", "test.txt");
<h2>TCP/IP 소개
<h3>TCP/IP 프로토콜
<h4> 두 시스템 간에 데이터가 손상없이 안
전하게 전송되도록 하는 통신 프로토콜
<h4> TCP에서 동작하는 응용프로그램 사례
<h5> e-mail, FTP, 웹(HTTP) 등
<h3> TCP/IP 특징
<h4> 연결형 통신
<h5>한 번 연결 후 계속 데이터 전송 가능
<h4> 보낸 순서대로 받아 응용프로그램에게
전달
<h2>IP 주소
<h3>네트워크 상에서 유일하게 식별될 수 있는 컴퓨터 주소
<h4> 숫자로 구성된 주소
<h4> 4개의 숫자가 ‘.’으로 연결
<h5> 예) 192.156.11.15
<h3> 숫자로 된 주소는 기억하기 어려우므로 www.naver.com과 같은
문자열로 구성된 도메인 이름으로 바꿔 사용
<h4> DNS(Domain Name System)
<h5> 문자열로 구성된 도메인 이름을 숫자로 구성된 IP 주소로 자동 변환
<h3> 현재는 32비트의 IP 버전 4(IPv4)가 사용되고 있음
<h4>IP 주소 고갈로 인해 128비트의 IP 버전 6(IPv6)이 점점 사용되는 추
세
<h3> 자신의 IP 주소를 간단히 localhost라는 이름으로 사용 가능
<h2>포트
<h3>통신하는 프로그램 간에 가상의 연결단 포트 생성
<h4> IP 주소는 네트워크 상의 컴퓨터 또는 시스템을 식별하는 주소
<h4> 포트 번호를 이용하여 통신할 응용프로그램 식별
<h3> 모든 응용프로그램은 하나 이상의 포트 생성 가능
<h4> 포트를 이용하여 상대방 응용프로그램과 데이터 교환
<h3> 잘 알려진 포트(well-known ports)
<h4> 시스템이 사용하는 포트 번호
<h4> 잘 알려진 응용프로그램에서
사용하는 포트 번호
<h5> 0부터 1023 사이의 포트 번호
<h5> ex) SSH 22, HTTP 80, FTP 21
<h4> 잘 알려진 포트 번호는
개발자가 사용하지 않는 것이 좋음
<h5> 충돌 가능성 있음
<h2>소켓 프로그래밍
<h3 TCP/IP 네트워크를 이용하여 쉽게 통신 프로그램을 작성하도록 지원
하는 기반 기술
<h3> 소켓
<h4> 두 응용프로그램 간의 양방향 통신 링크의 한쪽 끝 단
<h4> 소켓끼리 데이터를 주고받음
<h4> 소켓은 특정 IP 포트 번호와 결합
<h3> 자바로 소켓 통신할 수 있는 라이브러리 지원
<h3> 소켓 종류 : 서버 소켓과 클라이언트 소켓


# 6월 7일 강의
<h2>스윙의 페인팅 기본
<h3>모든 컴포넌트는 자신의 모양을 스스로 그린다.
<h3>컨테이너는 자신을 그린 후 그 위에 자식 컴포넌트들에게 그리기 지시
<h3>모든 스윙 컴포넌트는 자신의 모양을 그리는 paintComponent() 메소드 보유
<h2>public void paintComponent(Graphics g)
<h3>스윙 컴포넌트가 자신의 모양을 그리는 메소드
<h3>JComponent의 메소드 : 모든 스윙 컴포넌트가 이 메소드를 오버라이딩함
<h3>언제 호출되는가?
<h4>컴포넌트가 그려져야 하는 시점마다 호출
<h4>크기가 변경되거나, 위치가 변경되거나, 컴포넌트가 가려졌던 것이 사라지는 등
      개발자가 직접 호출하면 안 됨
<h3>매개변수인 Graphics 객체
<h4>그래픽 컨텍스트 : 컴포넌트 그리기에 필요한 도구를 제공하는 객체
<h4>자바 플랫폼에 의해 공급
<h4>색 지정, 도형 그리기, 클리핑, 이미지 그리기 등의 메소드 제공
<h3>paintComponent(Graphic g)의 오버라이딩
<h4>개발자가 JComponent를 상속받아 새로운 컴포넌트 설계
<h4>존 컴포넌트의 모양에 변화를 주고자 할 때
<h2>그래픽 기반 GUI 프로그래밍
<h3>스윙 컴포넌트에 의존하지 않고 선, 원 이미지 등을 이용하여 직접 화면
을 구성하는 방법
<h3>그래픽 기반 GUI 프로그래밍의 학습이 필요한 이유
<h4>컴포넌트의 한계를 극복하고 차트, 게임 등 자유로운 콘텐트 표현
<h4>그래픽은 컴포넌트에 비해 화면 출력 속도가 빠름
<h4> 스윙 컴포넌트들로 모두 그래픽으로 작성되어 있어, 그래픽에 대한 학습은 자
바 GUI의 바탕 기술을 이해하는데 도움
<h4>그래픽을 이용하여 개발자 자신만의 컴포넌트 개발
<h3>Graphics의 기능
<h4>색상 선택하기
<h4>문자열 그리기
<h4> 도형 그리기
<h4>도형 칠하기
<h4> 이미지 그리기
<h4> 클리핑
<h3>도형 그리기
<h4>선, 타원, 사각형, 둥근 모서리 사각형, 원호, 폐 다각형 그리기
<h4>선의 굵기 조절할 수 없음
<h3>도형 칠하기
<h4>도형을 그리고 내부를 칠하는 기능
<h5>도형의 외곽선과 내부를 따로 칠하는 기능 없음
<h4> 도형 칠하기를 위한 메소드
<h5>그리기 메소드 명에서 draw 대신 fill로 이름 대치하면 됨. fillRect(), fillOval() 등
<h2>1. JLabel을 이용한 이미지 그리기
<h3>장점 : 이미지 그리기 간편 용이
<h3<> 단점 : 이미지의 원본 크기대로 그리므로 이미지 크기 조절 불가
<h2. Graphics의 drawImage()로 이미지 출력
<h3>장점 : 이미지 일부분 등 이미지의 원본 크기와 다르게 그리기 가능
<h3>단점 : 컴포넌트로 관리할 수 없음
이미지의 위치나 크기 등을 적절히 조절하는 코딩 필요
<h2>repaint()
<h3> 모든 컴포넌트가 가지고 있는 메소드
<h3> 자바 플랫폼에게 컴포넌트 그리기를 강제 지시하는 메소드
<h3> repaint()를 호출하면, 자바 플랫폼이 컴포넌트의 paintComponent() 호출
<h2>repaint()의 호출이 필요한 경우
<h3> 개발자가 컴포넌트를 다시 그리고자 하는 경우
<h4> 프로그램에서 컴포넌트의 모양과 위치를 변경하고 바로 화면에 반영시키고자 하는 경우
<h4> 컴포넌트가 다시 그려져야 그 때 변경된 위치에 변경된 모양으로 출력됨
<h4> repaint()는 자바 플랫폼에게 지금 당장 컴포넌트를 다시 그리도록 지시함
<h2>부모 컴포넌트부터 다시 그리는 것이 좋음
<h3> 컴포넌트 repaint()가 불려지면
<h4> 이 컴포넌트는 새로운 위치에 다시 그려지지만 이전의 위치에 있던 자신의 모양이 남아 있음
<h3> 부모 컴포넌트의 repaint()를 호출하면
<h4> 부모 컨테이너의 모든 내용을 지우고 자식을 다시 그리기 때문에 컴포넌트의 이전 모양이 지워
지고 새로 변경된 크기나 위치에 그려짐
<h2>스레드(thread)
<h3> 운영체제에 의해 관리되는 하나의 작업 혹은 태스크
<h3> 스레드와 태스크(혹은 작업)은 바꾸어 사용해도 무관
<h2> 멀티스레딩(multi-threading)
<h3> 여러 스레드를 동시에 실행시키는 응용프로그램을 작성하는 기법
<h2>스레드 구성
<h3> 스레드 코드
<h4> 작업을 실행하기 위해 작성한 프로그램 코드
<h4> 개발자가 작성
<h3> 스레드 정보
<h4> 스레드 명, 스레드 ID, 스레드의 실행 소요 시간, 스레드의 우선 순위 등
<h4> 운영체제가 스레드에 대해 관리하는 정보
<h2>멀티태스킹 구현 기술
<h3> 멀티프로세싱(multi-processing)
<h4> 하나의 응용프로그램이 여러 개의 프로세스를 생성하고, 각 프로세스가 하나의 작업을 처리하는 기법
<h4> 각 프로세스 독립된 메모리 영역을 보유하고 실행
<h4> 프로세스 사이의 문맥 교환에 따른 과도한 오버헤드와 시간 소모의
문제점
<h3>멀티스레딩(multi-threading)
<h4> 하나의 응용프로그램이 여러 개의 스레드를 생성하고, 각 스레드가하나의 작업을 처리하는 기법
<h4> 하나의 응용프로그램에 속한 스레드는 변수 메모리, 파일 오픈 테이
블 등 자원으로 공유하므로, 문맥 교환에 따른 오버헤드가 매주 작음
<h4> 현재 대부분의 운영체제가 멀티스레딩을 기본으로 하고 있음




# 5월 31일 강의
<h2>자바의 GUI 프로그래밍 방법 2 종류
<h3>스윙 컴포넌트를 이용하여 쉽게 GUI를 구축
<h3>자바에서 제공하는 컴포넌트의 한계를 벗어나지 못함
<h2>그래픽 기반 GUI 프로그래밍
<h3>그래픽을 이용하여 GUI 구축
<h3>개발자가 직접 그래픽으로 화면을 구성하는 부담
<h3>독특한 GUI를 구성할 수 있는 장점
<h3>GUI 처리의 실행 속도가 빨라, 게임 등에 주로 이용
<h2>JLabel의 용도
<h3>문자열이나 이미지를 화면에 출력하기 위한 목적
<h2>JButton의 용도
<h3>버튼 모양의 컴포넌트. 사용자로부터 명령을 입력 받기 위한 목적
<h3>버튼은 클릭될 때 Action 이벤트 발생
<h2> 하나의 버튼에 3 개의 이미지 등록
<h3>마우스 조작에 따라 3 개의 이미지 중 적절한 이미지 자동 출력
<h2>3 개의 버튼 이미지
<h3> normalIcon
 <h4>버튼의 보통 상태(디폴트) 때 출력되는 이미지
 <h4>생성자에 이미지 아이콘 전달 혹은 JButton의 setIcon(normalIcon);
<h3>rolloverIcon
 <h4>버튼에 마우스가 올라갈 때 출력되는 이미지
 <h4>이미지 설정 메소드 : JButton의 setRolloverIcon(rolloverIcon);
<h3> pressedIcon
 <h4>버튼을 누른 상태 때 출력되는 이미지
 <h4>이미지 설정 메소드 : JButton의 setPressedIcon(pressedIcon)
<h2>Item 이벤트
<h3>체크 박스의 선택 상태에 변화가 생길 때 발생하는 이벤트
<h4>이벤트가 발생하면 ItemEvent 객체 생성
<h4>ItemListener 리스너를 이용하여 이벤트 처리





# 5월 24일 강의
<h2>이벤트 기반 프로그래밍(Event Driven Programming)<h2>
     이벤트의 발생에 의해 프로그램 흐름이 결정되는 방식<h3>
        이벤트가 발생하면 이벤트를 처리하는 루틴(이벤트 리스너) 실행<h3>
        실행될 코드는 이벤트의 발생에 의해 전적으로 결정
   <h2> 반대되는 개념 : 배치 실행(batch programming)
       프로그램의 개발자가 프로그램의 흐름을 결정하는 방식 
   <h2> 이벤트 종류
       <h3> 사용자의 입력 : 마우스 드래그, 마우스 클릭, 키보드 누름 등
      <h3>  센서로부터의 입력, 네트워크로부터 데이터 송수신
       <h3> 다른 응용프로그램이나 다른 스레드로부터의 메시지
  <h2>  이벤트 기반 응용 프로그램의 구조
       <h3>  각 이벤트마다 처리하는 리스너 코드 보유
      <h3>  GUI 응용프로그램은 이벤트 기반 프로그래밍으로 작성됨
      <h3>  GUI 라이브러리 종류
      <h3>  C++의 MFC, C# GUI, Visual Basic, X Window, Android 등
       <h3> 자바의 AWT와 Swing
    <h2>이벤트가 처리되는 과정
      <h3>  이벤트 발생
      <h3>  예 :마우스의 움직임 혹은 키보드입력
  <h2>  이벤트 객체
      <h3>  발생한 이벤트에 관한 정보를 가진 객체
       <h3> 이벤트 리스너에 전달됨
       <h3> 이벤트 리스너 코드가 발생한 이벤트에 대한 상황을 파악할 수 있게 함
    <h2>이벤트 객체가 포함하는 정보
       <h3> 이벤트 종류와 이벤트 소스
       <h3> 이벤트가 발생한 화면 좌표 및 컴포넌트 내 좌표
       <h3> 이벤트가 발생한 버튼이나 메뉴 아이템의 문자열
      <h3>  클릭된 마우스 버튼 번호 및 마우스의 클릭 횟수
       <h3> 키의 코드 값과 문자 값
       <h3> 체크박스, 라디오버튼 등과 같은 컴포넌트에 이벤트가 발생하였다면 체크 상태
<h2>이벤트 리스너 작성 방법
   <h3> 독립 클래스로 작성
       <h4> 이벤트 리스너를 완전한 클래스로 작성
      <h4>  이벤트 리스너를 여러 곳에서 사용할 때 적합
   <h3> 내부 클래스(inner class)로 작성
      <h4>  클래스 안에 멤버처럼 클래스 작성
       <h4> 이벤트 리스너를 특정 클래스에서만 사용할 때 적합
   <h3> 익명 클래스(anonymous class)로 작성
      <h4>  클래스의 이름 없이 간단히 리스너 작성
       <h4> 클래스 조차 만들 필요 없이 리스너 코드가 간단한 경우에 적합
    <h2>이벤트 리스너 구현에 따른 부담
   <h3> 리스너의 추상 메소드를 모두 구현해야 하는 부담
    <h3>예) 마우스 리스너에서 마우스가 눌러지는 경우(mousePressed())만 처리하고자 하는 경우에도            
     나머지 4 개의 메소드를 모두 구현해야 하는 부담
   <h2> 추상 메소드가 하나뿐인 리스너는 어댑터 없음
       <h3> ActionAdapter, ItemAdapter 클래스는 존재하지 않음
     <h2> Key 이벤트와 포커스
       <h3>키 입력 시, 다음 세 경우 각각 Key 이벤트 발생
       <h4> 키를 누르는 순간
      <h4>   누른 키를 떼는 순간
       <h4> 누른 키를 떼는 순간(Unicode 키의 경우에만)
    <h3>키 이벤트를 받을 수 있는 조건
      <h4>  모든 컴포넌트
      <h4>  현재 포커스(focus)를 가진 컴포넌트가 키 이벤트 독점
    <h3>포커스(focus)
      <h4>  컴포넌트나 응용프로그램이 키 이벤트를 독점하는 권한
       <h4> 컴포넌트에 포커스 설정 방법 : 다음 2 라인 코드 필요
   <h2> 유니코드 키의 특징
    <h3>국제 산업 표준
 <h3>전 세계의 문자를 컴퓨터에서 일관되게 표현하기 위한 코드 체계
 <h3>문자들에 대해서만 키 코드 값 정의
 <h4>A~Z, a~z, 0~9, !, @, & 등
 <h3>문자가 아닌 키 경우에는 표준화된 키 코드 값 없음
 <h4><Function> 키, <Home> 키, <Up> 키,<Delete> 키, <Control> 키, <Shift>
키, <Alt> 등은 플랫폼에 따라 키 코드 값이 다를 수 있음
<h2>유니코드 키가 입력되는 경우
<h3>keyPressed(), keyTyped(), keyReleased() 가 순서대로 호출
<h2>유니코드 키가 아닌 경우
 <h3>keyPressed(), keyReleased() 만 호출됨
 <h2>KeyEvent 객체
 <h3>입력된 키 정보를 가진 이벤트 객체
 <h3>KeyEvent 객체의 메소드로 입력된 키 판별
 <h2>KeyEvent 객체의 메소드로 입력된 키 판별
 <h3>char KeyEvent.getKeyChar()
 <h4>키의 유니코드 문자 값 리턴
 <h4>Unicode 문자 키인 경우에만 의미 있음
 <h4>입력된 키를 판별하기 위해 문자 값과 비교하면 됨
 <h2>int KeyEvent.getKeyCode()
 <h4>유니코드 키 포함
 <h4>모든 키에 대한 정수형 키 코드 리턴
<h4> 입력된 키를 판별하기 위해
<h4>가상키(Virtual Key) 값과 비교하여야 함
 <h4>가상 키 값은 KeyEvent 클래스에 상수로 선언


# 4월 26일 강의


# 4월 19일 강의
자바의 인터페이스

클래스가 구현해야 할 메소드들이 선언되는 추상형
인터페이스 선언

자바 인터페이스 특징
인터페이스 상속
1.인터페이스간에 상속 가능
2.인터페이스 다중 상속 허용
패키지 개념과 필요성 3명이 분담하여 자바 응용프로그램을 개발하는 경우 동일한 이름의 클래스가 존재할 가능성 있음

# 4월 12일 강의
static 멤버

클래스의 멤버들 중 다음과 같이 static 지시어로 선언된 멤버를 static 멤버라고 부른다
static으로 선언된 멤버는 non-static 멤버와 매우 다른 특성을 가진다
static 멤버는 클래스당 하나만 생성되는 멤버로서, 동일한 클래스의 모든 객체들이 공유하므로 클래스 멤버라고 부른다
non-static 멤버는 객체가 생길때 함께 생성되고 객체가 사라지면 함께 사라진다 그러나 static 멤버는 프로그램을 시작할 때나 클래스 로딩 시에 생성된다
객체를 생성하기 전에도 static 멤버는 사용
생성된 객체가 소멸된 후에도 static 멤버는 여전히 살아 공간을 차지하고 있으며 프로그램이 종료할 때 함께 소멸

상속(interitance)
객체 지향 상속 자식이 부모 유전자를 물려받는 것과 유사한 개념

상속의 장점
1.클래스의 사이의 멤버 중복 선언 불필요 - 클래스의 간결화
2.클래스들의 계층적 분류로 클래스 관리 용이
3.클래스 재사용과 확장을 통한 소프트웨어의 생산성 향상

서브 클래스/슈퍼 클래스의 생성사 호줄과 실행
1.서브 클래스의 객체가 생성될 때 슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행 호출 순서
2.서브 클래스의 생성자 먼저 호출 -서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출 실행 순서
3.슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

서브 클래스와 슈퍼 클래스의 생성자 선택
1.슈퍼 클래스와 서브 클래스 각각 여러 개의 생성자 작성 가능
2.서브 클래스의 객체가 생성될 때 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
3.서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식

# 4월 5일 강의
2차원 배열

2차원 배열의 선언과 생성 1차원 배열과 마찬가지로 2차원 배열에서도 레퍼런스 변수 선언 후 배열을 생성하며, 2차원 배열의 레퍼런스 변수를 선언 int inArray[][]; 또는 int [][] intArray; // 2차원 배열의 레퍼런스 변수 선언 intArray = new int[2][5]; // 2행 5열(2*5)의 2차원 배열 생성
2차원 배열의 초기화

2차원 배열을 선언할 때 각 원소를 초기화 할 수 있다. 자동으로 초기화된 배열이 생성된다. int inArray[][] = { {0,1,2}, {3,4,5}, {6,7,8} }; // 33 배열 생성 char charArray[][] = { {'a','b','c'}, {'d','e','f'} }; // 23 배열 생성 double doubleArray[][] = { {0.01,0.02}, {0.03,0.04} }; // 2*2 배열 생성

객체 지향 언어의 목적

1.소프트웨어의 생산성 향상
2.컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(life cycle) 단축
3.객체 지향 언어

실세계에 대한 쉬운 모델링

1.초기 프로그래밍
2.현대 프로그래밍
3.객체 지향 언어


## 3월 29일 Java2 강의
타입 변환이란 변수나 상수 혹은 리터럴을 다른 타입을 변환하는것을 말한다.

자동타입 변환: 치환문이나 수식 내에서 타입이 일치하지 않을때 컴파일러는 작은 타입을 큰 타입으로 자동변환
강제타입 변환(캐스팅) : 큰 타입을 작은 타입으로 변환해야 할때 자동 변환 대신 컴파일 오류 발생 손실이 발생한다는 사실을 알고 변환한다면 강제로()안에 타입을 지정
증강연산

++,-- 피연산자의 앞 또는 뒤에 붙어 값을 1 증가시키거나 1 감소시킨다. a++ a를 1 증가하고 증가전의 값 변환 ++a a를 1증가하고 증가된 값 변환 a-- a를 1 가모하고 감소 전의 값 변환 --a a를 1 감소하고 감소된 값 변환
대입 연산

연산자의 오른쪽 식의 결과를 왼쪽에 있는 변수에 대입
비교연산, 논리 연산

비교연산자는 두 개의 피연산자를 비교하여 true 또는 false의 논리 결과를 내는 연산자
논리 연산자는 논리 값을 대상으로 AND,OR,XOR,NOT의 논리 연산을 하여 논리 값을 내는 연산자
조건문

단순 IF문 조건식은 비교 연산이나 논리 연산의 혼합된 식으로 구성되며 결과는 불린 값이다.
조건식이 참이면 if 내부의 실행 문장이 실행되며 거짓이면 if문을 벗어난다
다중 if-else 문은 if의 '조건식'이 참인 경우와 거짓인 경우에 실행할 문장을 각각 지시한다

## 3월 22일 Java2 강의
자바의 특징 플래폼 독릭성,객체지향, 클래스로 캡슐화,소스와 클래스파일, 실행코드 배포 ,패키지, 멀티스레드,가비지컬렉션,실시간응용 시스템에 부적합, 자바 프로그램은 안전하다,프로그램 작서이 쉽다, 실행속도를 개선하기 위해 JIT 컴파일러가 사용됨.
식별자: 클래스,변수,상수,메소드에 붙이는 이름(identifier) 식별자 이름 규칙에서 식별자를 만들때 규칙을 준수하여야함. 
1.식별자로 한글을 사용할 수 있음.
2.길이제한이 없음.
3.대소문자를 구별한다.

## 3월 15일 Java2  강의
java 개발환경 구축 openJDK 설치, Eclips 설치, Eclips에 openJDK 연결 자바 프로젝트 생성





