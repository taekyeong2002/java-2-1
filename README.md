# <h1> 202130118 송태경

# 5월 31일 강의
<h2>자바의 GUI 프로그래밍 방법 2 종류
<h3>스윙 컴포넌트를 이용하여 쉽게 GUI를 구축
<h3>자바에서 제공하는 컴포넌트의 한계를 벗어나지 못함
<h2>그래픽 기반 GUI 프로그래밍
<h3>그래픽을 이용하여 GUI 구축
<h3>개발자가 직접 그래픽으로 화면을 구성하는 부담
<h3>독특한 GUI를 구성할 수 있는 장점
<h3>GUI 처리의 실행 속도가 빨라, 게임 등에 주로 이용
<h2>JLabel의 용도
<h3>문자열이나 이미지를 화면에 출력하기 위한 목적
<h2>JButton의 용도
<h3>버튼 모양의 컴포넌트. 사용자로부터 명령을 입력 받기 위한 목적
<h3>버튼은 클릭될 때 Action 이벤트 발생
<h2> 하나의 버튼에 3 개의 이미지 등록
<h3>마우스 조작에 따라 3 개의 이미지 중 적절한 이미지 자동 출력
<h2>3 개의 버튼 이미지
<h3> normalIcon
 <h4>버튼의 보통 상태(디폴트) 때 출력되는 이미지
 <h4>생성자에 이미지 아이콘 전달 혹은 JButton의 setIcon(normalIcon);
<h3>rolloverIcon
 <h4>버튼에 마우스가 올라갈 때 출력되는 이미지
 <h4>이미지 설정 메소드 : JButton의 setRolloverIcon(rolloverIcon);
<h3> pressedIcon
 <h4>버튼을 누른 상태 때 출력되는 이미지
 <h4>이미지 설정 메소드 : JButton의 setPressedIcon(pressedIcon)
<h2>Item 이벤트
<h3>체크 박스의 선택 상태에 변화가 생길 때 발생하는 이벤트
<h4>이벤트가 발생하면 ItemEvent 객체 생성
<h4>ItemListener 리스너를 이용하여 이벤트 처리




# 5월 24일 강의
<h2>이벤트 기반 프로그래밍(Event Driven Programming)<h2>
     이벤트의 발생에 의해 프로그램 흐름이 결정되는 방식<h3>
        이벤트가 발생하면 이벤트를 처리하는 루틴(이벤트 리스너) 실행<h3>
        실행될 코드는 이벤트의 발생에 의해 전적으로 결정
   <h2> 반대되는 개념 : 배치 실행(batch programming)
       프로그램의 개발자가 프로그램의 흐름을 결정하는 방식 
   <h2> 이벤트 종류
       <h3> 사용자의 입력 : 마우스 드래그, 마우스 클릭, 키보드 누름 등
      <h3>  센서로부터의 입력, 네트워크로부터 데이터 송수신
       <h3> 다른 응용프로그램이나 다른 스레드로부터의 메시지
  <h2>  이벤트 기반 응용 프로그램의 구조
       <h3>  각 이벤트마다 처리하는 리스너 코드 보유
      <h3>  GUI 응용프로그램은 이벤트 기반 프로그래밍으로 작성됨
      <h3>  GUI 라이브러리 종류
      <h3>  C++의 MFC, C# GUI, Visual Basic, X Window, Android 등
       <h3> 자바의 AWT와 Swing
    <h2>이벤트가 처리되는 과정
      <h3>  이벤트 발생
      <h3>  예 :마우스의 움직임 혹은 키보드입력
  <h2>  이벤트 객체
      <h3>  발생한 이벤트에 관한 정보를 가진 객체
       <h3> 이벤트 리스너에 전달됨
       <h3> 이벤트 리스너 코드가 발생한 이벤트에 대한 상황을 파악할 수 있게 함
    <h2>이벤트 객체가 포함하는 정보
       <h3> 이벤트 종류와 이벤트 소스
       <h3> 이벤트가 발생한 화면 좌표 및 컴포넌트 내 좌표
       <h3> 이벤트가 발생한 버튼이나 메뉴 아이템의 문자열
      <h3>  클릭된 마우스 버튼 번호 및 마우스의 클릭 횟수
       <h3> 키의 코드 값과 문자 값
       <h3> 체크박스, 라디오버튼 등과 같은 컴포넌트에 이벤트가 발생하였다면 체크 상태
<h2>이벤트 리스너 작성 방법
   <h3> 독립 클래스로 작성
       <h4> 이벤트 리스너를 완전한 클래스로 작성
      <h4>  이벤트 리스너를 여러 곳에서 사용할 때 적합
   <h3> 내부 클래스(inner class)로 작성
      <h4>  클래스 안에 멤버처럼 클래스 작성
       <h4> 이벤트 리스너를 특정 클래스에서만 사용할 때 적합
   <h3> 익명 클래스(anonymous class)로 작성
      <h4>  클래스의 이름 없이 간단히 리스너 작성
       <h4> 클래스 조차 만들 필요 없이 리스너 코드가 간단한 경우에 적합
    <h2>이벤트 리스너 구현에 따른 부담
   <h3> 리스너의 추상 메소드를 모두 구현해야 하는 부담
    <h3>예) 마우스 리스너에서 마우스가 눌러지는 경우(mousePressed())만 처리하고자 하는 경우에도            
     나머지 4 개의 메소드를 모두 구현해야 하는 부담
   <h2> 추상 메소드가 하나뿐인 리스너는 어댑터 없음
       <h3> ActionAdapter, ItemAdapter 클래스는 존재하지 않음
     <h2> Key 이벤트와 포커스
       <h3>키 입력 시, 다음 세 경우 각각 Key 이벤트 발생
       <h4> 키를 누르는 순간
      <h4>   누른 키를 떼는 순간
       <h4> 누른 키를 떼는 순간(Unicode 키의 경우에만)
    <h3>키 이벤트를 받을 수 있는 조건
      <h4>  모든 컴포넌트
      <h4>  현재 포커스(focus)를 가진 컴포넌트가 키 이벤트 독점
    <h3>포커스(focus)
      <h4>  컴포넌트나 응용프로그램이 키 이벤트를 독점하는 권한
       <h4> 컴포넌트에 포커스 설정 방법 : 다음 2 라인 코드 필요
   <h2> 유니코드 키의 특징
    <h3>국제 산업 표준
 <h3>전 세계의 문자를 컴퓨터에서 일관되게 표현하기 위한 코드 체계
 <h3>문자들에 대해서만 키 코드 값 정의
 <h4>A~Z, a~z, 0~9, !, @, & 등
 <h3>문자가 아닌 키 경우에는 표준화된 키 코드 값 없음
 <h4><Function> 키, <Home> 키, <Up> 키,<Delete> 키, <Control> 키, <Shift>
키, <Alt> 등은 플랫폼에 따라 키 코드 값이 다를 수 있음
<h2>유니코드 키가 입력되는 경우
<h3>keyPressed(), keyTyped(), keyReleased() 가 순서대로 호출
<h2>유니코드 키가 아닌 경우
 <h3>keyPressed(), keyReleased() 만 호출됨
 <h2>KeyEvent 객체
 <h3>입력된 키 정보를 가진 이벤트 객체
 <h3>KeyEvent 객체의 메소드로 입력된 키 판별
 <h2>KeyEvent 객체의 메소드로 입력된 키 판별
 <h3>char KeyEvent.getKeyChar()
 <h4>키의 유니코드 문자 값 리턴
 <h4>Unicode 문자 키인 경우에만 의미 있음
 <h4>입력된 키를 판별하기 위해 문자 값과 비교하면 됨
 <h2>int KeyEvent.getKeyCode()
 <h4>유니코드 키 포함
 <h4>모든 키에 대한 정수형 키 코드 리턴
<h4> 입력된 키를 판별하기 위해
<h4>가상키(Virtual Key) 값과 비교하여야 함
 <h4>가상 키 값은 KeyEvent 클래스에 상수로 선언


# 4월 26일 강의


# 4월 19일 강의
자바의 인터페이스

클래스가 구현해야 할 메소드들이 선언되는 추상형
인터페이스 선언

자바 인터페이스 특징
인터페이스 상속
1.인터페이스간에 상속 가능
2.인터페이스 다중 상속 허용
패키지 개념과 필요성 3명이 분담하여 자바 응용프로그램을 개발하는 경우 동일한 이름의 클래스가 존재할 가능성 있음

# 4월 12일 강의
static 멤버

클래스의 멤버들 중 다음과 같이 static 지시어로 선언된 멤버를 static 멤버라고 부른다
static으로 선언된 멤버는 non-static 멤버와 매우 다른 특성을 가진다
static 멤버는 클래스당 하나만 생성되는 멤버로서, 동일한 클래스의 모든 객체들이 공유하므로 클래스 멤버라고 부른다
non-static 멤버는 객체가 생길때 함께 생성되고 객체가 사라지면 함께 사라진다 그러나 static 멤버는 프로그램을 시작할 때나 클래스 로딩 시에 생성된다
객체를 생성하기 전에도 static 멤버는 사용
생성된 객체가 소멸된 후에도 static 멤버는 여전히 살아 공간을 차지하고 있으며 프로그램이 종료할 때 함께 소멸

상속(interitance)
객체 지향 상속 자식이 부모 유전자를 물려받는 것과 유사한 개념

상속의 장점
1.클래스의 사이의 멤버 중복 선언 불필요 - 클래스의 간결화
2.클래스들의 계층적 분류로 클래스 관리 용이
3.클래스 재사용과 확장을 통한 소프트웨어의 생산성 향상

서브 클래스/슈퍼 클래스의 생성사 호줄과 실행
1.서브 클래스의 객체가 생성될 때 슈퍼 클래스 생성자와 서브 클래스 생성자 모두 실행 호출 순서
2.서브 클래스의 생성자 먼저 호출 -서브 클래스의 생성자는 실행 전 슈퍼 클래스 생성자 호출 실행 순서
3.슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자 실행

서브 클래스와 슈퍼 클래스의 생성자 선택
1.슈퍼 클래스와 서브 클래스 각각 여러 개의 생성자 작성 가능
2.서브 클래스의 객체가 생성될 때 슈퍼 클래스 생성자 1개와 서브 클래스 생성자 1개가 실행
3.서브 클래스의 생성자와 슈퍼 클래스의 생성자가 결정되는 방식

# 4월 5일 강의
2차원 배열

2차원 배열의 선언과 생성 1차원 배열과 마찬가지로 2차원 배열에서도 레퍼런스 변수 선언 후 배열을 생성하며, 2차원 배열의 레퍼런스 변수를 선언 int inArray[][]; 또는 int [][] intArray; // 2차원 배열의 레퍼런스 변수 선언 intArray = new int[2][5]; // 2행 5열(2*5)의 2차원 배열 생성
2차원 배열의 초기화

2차원 배열을 선언할 때 각 원소를 초기화 할 수 있다. 자동으로 초기화된 배열이 생성된다. int inArray[][] = { {0,1,2}, {3,4,5}, {6,7,8} }; // 33 배열 생성 char charArray[][] = { {'a','b','c'}, {'d','e','f'} }; // 23 배열 생성 double doubleArray[][] = { {0.01,0.02}, {0.03,0.04} }; // 2*2 배열 생성

객체 지향 언어의 목적

1.소프트웨어의 생산성 향상
2.컴퓨터 산업 발전에 따라 소프트웨어의 생명 주기(life cycle) 단축
3.객체 지향 언어

실세계에 대한 쉬운 모델링

1.초기 프로그래밍
2.현대 프로그래밍
3.객체 지향 언어


## 3월 29일 Java2 강의
타입 변환이란 변수나 상수 혹은 리터럴을 다른 타입을 변환하는것을 말한다.

자동타입 변환: 치환문이나 수식 내에서 타입이 일치하지 않을때 컴파일러는 작은 타입을 큰 타입으로 자동변환
강제타입 변환(캐스팅) : 큰 타입을 작은 타입으로 변환해야 할때 자동 변환 대신 컴파일 오류 발생 손실이 발생한다는 사실을 알고 변환한다면 강제로()안에 타입을 지정
증강연산

++,-- 피연산자의 앞 또는 뒤에 붙어 값을 1 증가시키거나 1 감소시킨다. a++ a를 1 증가하고 증가전의 값 변환 ++a a를 1증가하고 증가된 값 변환 a-- a를 1 가모하고 감소 전의 값 변환 --a a를 1 감소하고 감소된 값 변환
대입 연산

연산자의 오른쪽 식의 결과를 왼쪽에 있는 변수에 대입
비교연산, 논리 연산

비교연산자는 두 개의 피연산자를 비교하여 true 또는 false의 논리 결과를 내는 연산자
논리 연산자는 논리 값을 대상으로 AND,OR,XOR,NOT의 논리 연산을 하여 논리 값을 내는 연산자
조건문

단순 IF문 조건식은 비교 연산이나 논리 연산의 혼합된 식으로 구성되며 결과는 불린 값이다.
조건식이 참이면 if 내부의 실행 문장이 실행되며 거짓이면 if문을 벗어난다
다중 if-else 문은 if의 '조건식'이 참인 경우와 거짓인 경우에 실행할 문장을 각각 지시한다

## 3월 22일 Java2 강의
자바의 특징 플래폼 독릭성,객체지향, 클래스로 캡슐화,소스와 클래스파일, 실행코드 배포 ,패키지, 멀티스레드,가비지컬렉션,실시간응용 시스템에 부적합, 자바 프로그램은 안전하다,프로그램 작서이 쉽다, 실행속도를 개선하기 위해 JIT 컴파일러가 사용됨.
식별자: 클래스,변수,상수,메소드에 붙이는 이름(identifier) 식별자 이름 규칙에서 식별자를 만들때 규칙을 준수하여야함. 
1.식별자로 한글을 사용할 수 있음.
2.길이제한이 없음.
3.대소문자를 구별한다.

## 3월 15일 Java2  강의
java 개발환경 구축 openJDK 설치, Eclips 설치, Eclips에 openJDK 연결 자바 프로젝트 생성





